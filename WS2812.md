# GPIO-TIM-DMA初始化

```c
#define Code0 		30//0码	占重装载值在1/3
#define Code1 		60//1码	占重装载值在2/3
#define CodeReset 	0//reset码
#define LED_COUNT   42//LED灯珠数量
#define BUFFER_SIZE (LED_COUNT * 24+1)// 每个LED 24位 + RESET
#define GPIO_Pin GPIO_Pin_0//引脚
#define GPIOS GPIOA        //GPIO


uint16_t pwm_buffer[BUFFER_SIZE];				

void My_PWM_Init(void){
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);//开启TIM2时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);//开启GPIOA的时钟
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);//开启DMA时钟
		
	GPIO_InitTypeDef MY_GPIO_PWM;//定义结构体
	MY_GPIO_PWM.GPIO_Mode = GPIO_Mode_AF_PP;//GIPO复用推挽输出
	MY_GPIO_PWM.GPIO_Pin = GPIO_Pin;//PIN_0
	MY_GPIO_PWM.GPIO_Speed = GPIO_Speed_50MHz;//速度50MHZ
	GPIO_Init(GPIOS,&MY_GPIO_PWM);//初始化
	
	//TIM_InternalClockConfig(TIM2);//开启TIM2的外部时钟
	
	TIM_TimeBaseInitTypeDef MY_TIM_Base_Init;//定义TIM时基单元结构体
	MY_TIM_Base_Init.TIM_ClockDivision = TIM_CKD_DIV1;//不分频
	MY_TIM_Base_Init.TIM_CounterMode = TIM_CounterMode_Up;//向上计数模式
	MY_TIM_Base_Init.TIM_Period = (72000000/800000 - 1);//重装载寄存器，须注意的是ws2812最大信号频率为800Khz
	MY_TIM_Base_Init.TIM_Prescaler = 0;//预分配寄存器
	TIM_TimeBaseInit(TIM2,&MY_TIM_Base_Init);
		
	
	TIM_OCInitTypeDef MY_TIM_OC_Init;
	MY_TIM_OC_Init.TIM_OCMode = TIM_OCMode_PWM1;//PWM1模式，计数器小于比较值为有效电平，反之
	MY_TIM_OC_Init.TIM_OCPolarity = TIM_OCPolarity_High;//输出比较极性高电平
	MY_TIM_OC_Init.TIM_OutputState = TIM_OutputState_Enable;//输出比较使能
	MY_TIM_OC_Init.TIM_Pulse = 0;
	TIM_OC1Init(TIM2,&MY_TIM_OC_Init);
	
	TIM_CtrlPWMOutputs(TIM2, ENABLE);//使能TIM2的主输出，主要用于高级定时器
	TIM_DMAConfig(TIM2,TIM_DMABase_CCR1,TIM_DMABurstLength_1Transfer);//DMA传输范围只在CCR1
	TIM_OC1PreloadConfig(TIM2,TIM_OCPreload_Enable);//使能预装载寄存器
	TIM_DMACmd(TIM2,TIM_DMA_CC1,DISABLE);//失能DMA触发事件
	TIM_ARRPreloadConfig(TIM2,ENABLE);//使能预装载寄存器
	TIM_Cmd(TIM2,DISABLE);//失能TIM
	
	DMA_DeInit(DMA1_Channel5);//恢复默认
	DMA_InitTypeDef My_DMA_Init;
	My_DMA_Init.DMA_MemoryBaseAddr = (uint32_t)&pwm_buffer;//源地址
	My_DMA_Init.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;//传输大小16bit
	My_DMA_Init.DMA_PeripheralBaseAddr = (uint32_t)&TIM2->CCR1;//目的地址
	My_DMA_Init.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;//传输大小16bit
	My_DMA_Init.DMA_BufferSize = BUFFER_SIZE;//DMA传输总量大小
	My_DMA_Init.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//禁止目的地址自增
	My_DMA_Init.DMA_MemoryInc = DMA_MemoryInc_Enable;//禁止源地址自增
	My_DMA_Init.DMA_Mode = DMA_Mode_Normal;//普通模式
	My_DMA_Init.DMA_DIR = DMA_DIR_PeripheralDST;//传输方向内存到外设
	My_DMA_Init.DMA_M2M = DMA_M2M_Disable;//禁用内存到内存
	My_DMA_Init.DMA_Priority = DMA_Priority_Medium;//通道优先级中等
	DMA_Init(DMA1_Channel5,&My_DMA_Init);//初始化
	
	DMA_ITConfig(DMA1_Channel5, DMA_IT_TC, ENABLE);//使能传输完成中断
	DMA_Cmd(DMA1_Channel5,DISABLE);//失能DMA
}
```

# 设置灯珠样式

```c
/**@brief 设置灯珠颜色以及位置
  *@param index 灯珠位置0 - LED_COUNT
  *@param r 红色范围0-255
  *@param g 绿色范围0-255
  *@param b 蓝色范围0-255
  *@return 无
  */
void Set_LED_RGB(uint16_t index, uint16_t r, uint16_t g, uint16_t b) {
    if (index < LED_COUNT) {//防止越界
        uint16_t* ptr = &pwm_buffer[index * 24]; 
        byte_to_pwm(g, ptr); 
        ptr += 8;
        byte_to_pwm(r, ptr);
        ptr += 8;
        byte_to_pwm(b, ptr); 
        ptr += 8;
    }
}
/**@brief 8bit数据转换成（Code0 / Code1）
  *@param data 转换字节
  *@param buffer 缓冲区
  *@return 无
  */
void byte_to_pwm(uint16_t data, uint16_t* buffer) {
    for (int i = 7; i >= 0; i--) {
        *buffer++ = (data >> i) & 0x01 ? Code1 : Code0;
    }
}
/**@brief 更新说有状态灯
  *@return 无
  */
void Update_LEDs(void) {
    //添加reset码
    pwm_buffer[LED_COUNT * 24] = CodeReset;

    //为安全着想关闭DMA和定时器，防止冲突
    DMA_Cmd(DMA1_Channel5, DISABLE);
    TIM_Cmd(TIM2, DISABLE);
    TIM_DMACmd(TIM2, TIM_DMA_CC1, DISABLE);
    
    //设置DMA传输长度：LED_COUNT * 24 bits + 1 个 Reset 码
    DMA_SetCurrDataCounter(DMA1_Channel5, LED_COUNT * 24 + 1);

    //新启动开启定时器和DMA
    TIM_DMACmd(TIM2, TIM_DMA_CC1, ENABLE);
    TIM_Cmd(TIM2, ENABLE);
    DMA_Cmd(DMA1_Channel5, ENABLE);

    //等待DMA完成
    while (!DMA_GetFlagStatus(DMA1_FLAG_TC5));
    //清除标准位
    DMA_ClearFlag(DMA1_FLAG_TC5);

    //关闭 DMA 和定时器
    TIM_DMACmd(TIM2, TIM_DMA_CC1, DISABLE);
    DMA_Cmd(DMA1_Channel5, DISABLE);
    TIM_Cmd(TIM2, DISABLE);
}
```

# 示例

```c
void main(void){
    My_PWM_Init();
    while(1){
        //循环设置所有LED为蓝色
        for (int i = 0; i < LED_COUNT ; i++) {
            Set_LED_RGB(i, 0, 0, 255);  // 蓝色
        }
        Update_LEDs();  // 更新所有LED显示
    }
}
```

